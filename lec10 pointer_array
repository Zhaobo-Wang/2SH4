pointer:

p + i / p - i are pointers
————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
举个例子：

# include <stdio.h>

int main(){

int a[5] = {0, 1, 2, 3, 4};
int *aPtr;
aPtr = &a[1];//原本指向array中第二个

printf("%d", *(aPtr+3)); // *(aPtr + 3) 的意义，现在指向第第五个

return 0;

}
——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
p 和 q 都是pointers， 它们分别指向array中的不同的elements
那么 p - q 的意义就是 the difference of array position + 1
举个例子：

# include <stdio.h>

int main(){

int a[5] = {0, 5, 8, 16, 26};
int *p;
int *q;

p = &a[1];//指向第二个element

q = &a[3];//指向第四个element

printf("%d", q - p); //算出中间的差了几个element + 1， 所以这里return 2

return 0;

}


——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

举个例子：

# include <stdio.h>

int main(){

int a[5] = {0, 5, 8, 16, 26};
int *p;

p = &a[0];//指向第一个element

*(p + 2) = 0; //把第三个element的值改为0

for (int i; i < 5; i ++){
    printf("%d, ", *(p+i));  // 从pointer指向的第一个element开始，往上循环累加 (叫做 offset notation)
    //加到最后一个结束
    // print出来的结果为： 0， 5， 0， 16， 26
}

return 0;

}

——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

Array的名字是一个 地址 （address）， 当array 名字 pass给一个function的时候 对于function的parameter来讲
就是一个pointer一样

# include <stdio.h>
# define N 3

void f2(int *pa, int n);

int main(void){
    int i;
    int a[N] = {0,1,2};

    f2(a,N);
    for(int i = 0; i < N; i++){
        printf("a[%d] = %d\t",i,a[i]);
    }
    return 0;
}

void f2(int *pa, int n){//把 array 名字（地址）pass 过来 直接用pointer来接收它的value
    int i;
    for (i = 0; i < n; i++){
        pa[i] *=3;
        // pa【i】乘以2， return 最后结果
        // a[0] = 0, a[1] = 3, a[2] = 6
    }
}

——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

之前的内存大小都是固定的 
现在变成 动态内存
functions： malloc（），calloc（）
free（）；

void* malloc(size_t n);
storage 初始的size 没有给确定大小，只是预留了那个部分的内存
void* calloc(size_t m, size_t n);
storage 初始的size 也给保留大小， initialized to 0







